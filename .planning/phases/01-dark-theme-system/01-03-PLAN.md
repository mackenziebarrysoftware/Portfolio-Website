---
phase: 01-dark-theme-system
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified:
  - src/components/theme/ThemeToggle.tsx
  - src/components/layout/Navbar.tsx
  - src/components/ui/Button.tsx
  - src/components/ui/Card.tsx
  - tailwind.config.js
autonomous: true

must_haves:
  truths:
    - "User can toggle between dark and light themes by clicking toggle button"
    - "Theme preference persists when user refreshes page"
    - "All interactive elements have visible hover states in both themes"
    - "Focus indicators meet 3:1 contrast in both themes"
  artifacts:
    - path: "src/components/theme/ThemeToggle.tsx"
      provides: "Theme switching UI control"
      exports: ["ThemeToggle"]
      min_lines: 30
    - path: "src/components/ui/Button.tsx"
      contains: "bg-primary text-primary-foreground"
      provides: "Theme-aware button component"
    - path: "src/components/ui/Card.tsx"
      contains: "bg-card text-card-foreground"
      provides: "Theme-aware card component"
  key_links:
    - from: "src/components/theme/ThemeToggle.tsx"
      to: "next-themes useTheme hook"
      via: "reads theme state and calls setTheme"
      pattern: "useTheme\\(\\)"
    - from: "src/components/layout/Navbar.tsx"
      to: "src/components/theme/ThemeToggle.tsx"
      via: "renders toggle in navigation"
      pattern: "<ThemeToggle"
    - from: "src/components/ui/Button.tsx"
      to: "globals.css semantic tokens"
      via: "uses bg-primary, text-primary-foreground classes"
      pattern: "bg-primary"
---

<objective>
Implement theme toggle UI and migrate components to semantic color tokens with polished hover states.

Purpose: Users need visible control to switch themes. Components must use semantic tokens to automatically adapt to theme changes. Hover states provide visual feedback signaling interactivity per DSGN-06.

Output: Functional theme switching with all components using semantic tokens and polished interactions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dark-theme-system/01-RESEARCH.md
@.planning/phases/01-dark-theme-system/01-01-SUMMARY.md
@.planning/phases/01-dark-theme-system/01-02-SUMMARY.md
@src/components/layout/Navbar.tsx
@src/components/ui/Button.tsx
@src/components/ui/Card.tsx
@src/app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThemeToggle component with hydration safety</name>
  <files>
    src/components/theme/ThemeToggle.tsx
  </files>
  <action>
Create src/components/theme/ThemeToggle.tsx:

```typescript
'use client'

import { useTheme } from 'next-themes'
import { Moon, Sun } from 'lucide-react'
import { useEffect, useState } from 'react'

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()
  const [mounted, setMounted] = useState(false)

  // Avoid hydration mismatch by not rendering until client-side mount
  useEffect(() => {
    setMounted(true)
  }, [])

  if (!mounted) {
    // Return invisible placeholder with same dimensions to prevent layout shift
    return (
      <div className="h-10 w-10 rounded-lg" aria-hidden="true" />
    )
  }

  return (
    <button
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
      className="rounded-lg p-2 hover:bg-secondary/80 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background transition-colors"
      aria-label={`Switch to ${theme === 'dark' ? 'light' : 'dark'} theme`}
      title={`Switch to ${theme === 'dark' ? 'light' : 'dark'} theme`}
    >
      {theme === 'dark' ? (
        <Sun className="h-5 w-5 text-foreground" />
      ) : (
        <Moon className="h-5 w-5 text-foreground" />
      )}
    </button>
  )
}
```

Key patterns:
- mounted state prevents hydration mismatch (server doesn't know theme, client does)
- Placeholder maintains layout dimensions during hydration
- Semantic tokens (bg-secondary, text-foreground, ring-ring) auto-adapt to theme
- Proper ARIA labels for accessibility
- Focus ring meets 3:1 contrast requirement
  </action>
  <verify>
File exists, contains 'use client', uses useTheme hook, has mounted state check, returns placeholder when not mounted, has proper hover and focus-visible states.
  </verify>
  <done>
ThemeToggle.tsx created with hydration-safe rendering, semantic token usage, and accessible focus states.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ThemeToggle in Navbar</name>
  <files>
    src/components/layout/Navbar.tsx
  </files>
  <action>
Update Navbar.tsx to include ThemeToggle:

1. Import ThemeToggle at top:
```typescript
import { ThemeToggle } from '@/components/theme/ThemeToggle'
```

2. Add ThemeToggle to the navbar, typically in the right-side navigation area (after navigation links, before or after any CTA buttons). Place it where it's easily discoverable but doesn't interfere with primary navigation.

Example placement (adapt to existing Navbar structure):
```typescript
{/* Desktop navigation */}
<nav className="hidden md:flex items-center gap-6">
  {/* existing nav links */}
  <ThemeToggle />
</nav>

{/* Mobile navigation */}
<div className="md:hidden">
  {/* existing mobile menu */}
  <div className="flex items-center gap-4">
    <ThemeToggle />
    {/* mobile menu button */}
  </div>
</div>
```

Ensure ThemeToggle is visible on both desktop and mobile layouts.
  </action>
  <verify>
Read Navbar.tsx - confirms import statement exists, ThemeToggle component rendered in both desktop and mobile navigation sections.
  </verify>
  <done>
Navbar integrates ThemeToggle in accessible location for both desktop and mobile views.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Button component with semantic tokens and polished hover states</name>
  <files>
    src/components/ui/Button.tsx
  </files>
  <action>
Update Button.tsx to use semantic color tokens and add polished hover states:

```typescript
import * as React from 'react'
import { cn } from '@/lib/utils'

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost'
  size?: 'sm' | 'md' | 'lg'
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'primary', size = 'md', ...props }, ref) => {
    const variants = {
      primary:
        'bg-primary text-primary-foreground hover:bg-primary/90 focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background',
      secondary:
        'bg-secondary text-secondary-foreground hover:bg-secondary/80 focus-visible:ring-2 focus-visible:ring-ring',
      outline:
        'border-2 border-input bg-transparent hover:bg-accent hover:text-accent-foreground focus-visible:ring-2 focus-visible:ring-ring',
      ghost:
        'hover:bg-accent hover:text-accent-foreground focus-visible:ring-2 focus-visible:ring-ring',
    }

    const sizes = {
      sm: 'h-9 px-3 text-sm',
      md: 'h-10 px-4 py-2',
      lg: 'h-11 px-8 text-lg',
    }

    return (
      <button
        className={cn(
          'inline-flex items-center justify-center rounded-md font-medium transition-colors disabled:opacity-50 disabled:pointer-events-none',
          variants[variant],
          sizes[size],
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)

Button.displayName = 'Button'

export { Button }
```

Changes from existing:
- Replace hardcoded colors with semantic tokens (bg-primary, text-primary-foreground, etc.)
- Add hover states using opacity modifiers (hover:bg-primary/90)
- Add focus-visible ring with proper contrast (ring-2 ring-ring)
- Add transition-colors for smooth state changes
- All variants auto-adapt to dark/light theme via semantic tokens
  </action>
  <verify>
Read Button.tsx - confirms semantic token usage (bg-primary, text-primary-foreground, bg-secondary, border-input, bg-accent), hover states with opacity modifiers, focus-visible rings, transition-colors class.
  </verify>
  <done>
Button component uses semantic color tokens, implements polished hover states with smooth transitions, meets DSGN-06 requirement.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Card component with semantic tokens</name>
  <files>
    src/components/ui/Card.tsx
  </files>
  <action>
Update Card.tsx to use semantic color tokens:

```typescript
import * as React from 'react'
import { cn } from '@/lib/utils'

export interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  hover?: boolean
}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, hover = false, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'rounded-lg border border-border bg-card text-card-foreground shadow-sm',
          hover && 'transition-all duration-300 hover:shadow-lg hover:scale-[1.02] hover:border-primary/50',
          className
        )}
        {...props}
      />
    )
  }
)

Card.displayName = 'Card'

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
))

CardHeader.displayName = 'CardHeader'

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn('text-2xl font-semibold leading-none tracking-tight text-foreground', className)}
    {...props}
  />
))

CardTitle.displayName = 'CardTitle'

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
))

CardDescription.displayName = 'CardDescription'

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
))

CardContent.displayName = 'CardContent'

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
))

CardFooter.displayName = 'CardFooter'

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

Changes:
- Replace hardcoded colors with semantic tokens (bg-card, text-card-foreground, border-border)
- Add optional hover prop for interactive cards with scale and shadow effects
- Add hover:border-primary/50 for subtle color feedback
- Use text-foreground and text-muted-foreground for typography
- All elements auto-adapt to theme changes
  </action>
  <verify>
Read Card.tsx - confirms semantic tokens (bg-card, text-card-foreground, border-border, text-foreground, text-muted-foreground), hover prop with transition effects, scale and shadow on hover.
  </verify>
  <done>
Card component uses semantic tokens with optional polished hover effects, integrates with theme system automatically.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update Tailwind config to expose semantic tokens as utilities</name>
  <files>
    tailwind.config.js
  </files>
  <action>
Update tailwind.config.js to ensure semantic tokens are accessible as Tailwind utilities:

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: 'var(--color-background)',
        foreground: 'var(--color-foreground)',
        card: {
          DEFAULT: 'var(--color-card)',
          foreground: 'var(--color-card-foreground)',
        },
        primary: {
          DEFAULT: 'var(--color-primary)',
          foreground: 'var(--color-primary-foreground)',
        },
        secondary: {
          DEFAULT: 'var(--color-secondary)',
          foreground: 'var(--color-secondary-foreground)',
        },
        muted: {
          DEFAULT: 'var(--color-muted)',
          foreground: 'var(--color-muted-foreground)',
        },
        accent: {
          DEFAULT: 'var(--color-accent)',
          foreground: 'var(--color-accent-foreground)',
        },
        border: 'var(--color-border)',
        input: 'var(--color-input)',
        ring: 'var(--color-ring)',
      },
      fontFamily: {
        serif: ['var(--font-serif)', 'serif'],
        sans: ['var(--font-sans)', 'sans-serif'],
      },
    },
  },
  plugins: [],
}
```

This configuration:
- Maps Tailwind utility classes (bg-primary, text-foreground) to CSS variables from @theme
- Enables classes like bg-card, text-card-foreground, border-border
- Preserves existing font configuration
- Removes old cream/charcoal/accent color definitions (replaced by semantic tokens)
  </action>
  <verify>
Read tailwind.config.js - confirms colors object maps semantic token names to CSS variables, old color definitions removed, font configuration preserved.
  </verify>
  <done>
Tailwind config exposes semantic tokens as utility classes, enabling theme-aware styling throughout codebase.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run dev` and open http://localhost:3000
2. Verify ThemeToggle appears in navbar on desktop and mobile
3. Click toggle - theme should switch immediately without page flash
4. Refresh page - theme preference should persist (check localStorage has 'theme' key)
5. Test hover states on buttons and cards in both themes - should have smooth transitions
6. Test keyboard navigation - focus rings should be visible in both themes
7. Inspect components in DevTools - should use CSS variables (var(--color-background), etc.)
</verification>

<success_criteria>
- ThemeToggle component created with hydration-safe rendering
- Navbar integrates ThemeToggle in visible location
- Button component uses semantic tokens with polished hover states and focus rings
- Card component uses semantic tokens with optional hover effects
- Tailwind config maps semantic tokens to utility classes
- Theme switching works without FOUC or hydration errors
- Theme preference persists across page refreshes
- All interactive elements have visible, accessible hover and focus states
- Build completes without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-dark-theme-system/01-03-SUMMARY.md` documenting:
- ThemeToggle implementation approach and hydration safety pattern
- Component migration strategy (semantic tokens vs dark: prefixes)
- Hover state decisions (opacity modifiers, scale transforms, transitions)
- Any challenges encountered during component updates
- Visual testing notes for both themes
</output>
